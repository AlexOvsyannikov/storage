# API для работы с аппаратной частью умного склада
Содержание:  
1. Классы-наследники StorageApi и их основные методы
2. Класс StorageMaker
3. Маршруты
4. Вспомогательные классы
  
  # Классы Storage
  1. `StorageApi` - родитель всех классов с названием Storage. 
  Он работает на основе запросов к аппаратной части, при этом, все методы возвращают текст.
  Для инициализации требует хост и порт сервера с запущенной аппаратной частью.
  Имеет следующие методы:
      * `get_schema_api()`
      * `put_item_api(data)`
      * `position_api(destination)  `
  
  2. `RenderStorage` - наследник StorageApi, отвечает за отрисовку схемы склада, при инициализации собирает все данные, которые можно собрать для работы со складом.
  Основная функция - `render()`, остальные функции служебные. 
 
  3. `Storage` - наследник RenderStorage, в нем определена вся логика распределения товаров на складе.
  Методы:
  
      * `put(way_bill)` - принимает на вход объект класса WayBill, вызывает служебный метод 
      `_solve_how_to_put(items)`, в который передает список объектов Items, возвращает в итоге
      2 варианта ответа:
        1. OK
        2. ERROR  
       * `get(uuid = "", type_of_work = 0, cell_name = "")` - в зависимости от параметра, может искать позицию на складе, как через uuid, так и через имя полки.
       При type_of_work=0, использует uuid, не требуя cell_name.
       При type_of_work=1, использует cell_name, не требуя uuid.  
   4. `StorageImproved` - наследник Storage, был создан, чтобы просто добавить массив unique_cells, 
   который упрощает рендер html-страниц, в unique_cells нет клеток, которые находятся в одной группе объединения.
   # Класс StorageMaker
   Этот класс необходим для хранения в себе объекта StorageImproved, через которого осуществляется вся логика программы.
   Также класс решает важную проблему сохранения данных: `save()` вызывает переопределенный магический метод `__del__()`, который всегда вызывается при уничтожении объекта сборщиком мусора.
   Таким образом, переопределение метода `__del__()` позволяет сохранить данные, даже при аварийном завершении работы. 
   # Обслуживаемые маршруты
   ## 1. GET:
   * `/` - возвращает веб-страницу с информацией о ячейках склада
   * `/remote` - возвращает веб-страницу с информацией о товарах на удаленном складе
   * `/report` - возвращает пустую веб-страницу, но функция, обернутая в декоратор, используется для генерации отчетов в формате .pdf
   * `/get_storage_scheme` - возвращает актуальную схему склада для визуализации в формате .png
   * `/get_list_of_all` - возвращает список объектов класса Cell, сериализованных через pickle, список закодирован в base64.
   * `/get_cell` - параметром принимает название клетки, например A1.
   Возвращает, либо строку `Not`, закодированный в base64, если полку с таким названием найти не удалось, либо соответсвующий объект класса Cell, сериализованный с помощью pickle и закодированный в base64.
   * `/get_data_from_item_search` - параметром принимает строку uuid.
   Возвращает, либо строку `Not`, закодированный в base64, если uuid найти не удалось, либо соответсвующий объект класса Cell, сериализованный с помощью pickle и закодированный в base64, в котором хранится объект класса Item с искомым uuid.
   * `/get_item_from_storage` - позволяет забрать со склада объект, параметром принимает, либо `cell_name`, либо `uuid`.
   Возвращает строку со статусом операции. Возможных варианта 3: 
    1. `Position is empty`, если запрашиваемая позиция пуста
    2. `OK`, если все прошло хорошо
    3. `ERROR`, если произошла ошибка
    Автоматически обновляет схему склада, которую можно получить через `get_storage_scheme`
   * `/get_pdf_main` - возвращает pdf с последней версией отчета о добавлении товаров на склад
   * `/get_pdf_remote` - возвращает pdf с последней версией отчета о добавлении товаров на удаленный склад
   
  ## 2. POST:
  * `/put_items_to_storage` - позволяет добавить несколько объектов на склад. Принимает .xlsx файл, закодированный в base64.
  Возвращает строку формата `статус_ответа.статус_генерации_pdf_для_склада.статус_генерации_pdf_для_удаленного_склада`, например, строка
  `OK.1.0` означает, что запрос был выполнен успешно, также был сгенерирован файл pdf с отчетом о добавленных товарах. 
  Отчет о добавлении товаров на удаленный склад не генерируется, если все объекты поместились на основном складе. 
  Если на основном складе нет места и все товары из накладной были отправлены на удаленный склад, то отчет для основого склада сгенерирован не будет.
  В зависимости от статуса генерации файлов, можно понять, нужно ли обращаться за файлами на сервер.
  Всего может быть 3 статуса ответа:
    1. `CANNOT BE OPENED` - означает, что файл не удалось открыть.
    2. `OK` - все прошло успешно.
    3. `ERROR` - произошла ошибка
    
# Вспомогательные классы:
## 1. Cell
Хранит информацию о полке, также, если полка занята товаром, то хранит объект класса Item.  
Основные методы:
* `put_to_cell(item: Item)` - принимает на вход объект класса Item и сохраняет его в атрибут `contained_item`.
* `get_from_item()` - освобождает полку, присваевает атрибуту `contained_item` значение `None`.
* `make_rendered()` - присваивает логическому атрибуту `rendered` значение `True`, используется классом `RenderStorage` для отрисовки схемы склада.
* `make_not_rendered()`- присваивает логическому атрибуту `rendered` значение `False`, используется классом `RenderStorage` для отрисовки схемы склада.
Объекты класса Cell генерируются при инициализации наследников `StorageApi`. 
## 2. Item
Каждый объект этого класса хранит информацию об отдельном товаре. Для этого класса переопределены магические методы, отвечающие за сравнение.
Это сделано для того, чтобы можно было отсортировать массив с объектами Item, основываясь на массе. Специальных методов не имеет, используется, как хранилище данных о товаре.
## 3. WayBill
Класс, который при инициализации принимает путь до таблицы формата .xlsx, если файл не был найден, то вернется `FileNotFoundError`
Имеет два метода:
* `create_item_list()` - парсит данную таблицу и возвращает отсортированный список объектов класса Item
* `set_fileway(fileway)` - обновляет путь до файла
## 4. TempStorage
Этот класс позволяет хранить временные данные для генерации pdf-отчетов о добавленных на склад товарах. При инициализации создает два пустых списка: items и cells.
Основные методы:
* `add_item(item: Item)` - добавляет в список items объект класса Item
* `add_pair(item: Item, cell: Cell)` - добавляет в список items объект класса Item, а в список cells объект класса Cell
* `get_items()` - возвращает список items
* `get_pair()` - возваращет кортеж, первым элементом, которого является список items, а вторым - список cells
## 5. RemoteDataStorage
Используется для постоянного хранения данных, об элементах удаленного склада. При инициализации ищет файл remote_storage_data, если его нет, то создает пустой список items.
Основные методы:
* `add_item(item: Item)` - добавляет в список items объект класса Item
* `get_items()` - возвращает список items
* `save_items()` - вызывает переопределенный метод `__del()__`, который сохраняет в файл список items
## 6. TalkToDB
Изначально был задуман для общения с БД, сейчас используется для хранения временных данных и данных об удаленном складе.
Основные методы:
* `make_temp_storages()` - генерирует 2 временных хранилища для создания отчетов.
* `send_to_db(item: Item, cell: Cell)` - вызывает метод `add_pair(item: Item, cell: Cell)` у экземпляра класса TempStorage, который отвечает за временные данные основоного склада.
* `send_to_remote_db(item: Item)` - записывает данные о товаре, добавленном на удаленный склад, также добавляет товар во временное хранилище для отчета.

## 7. PDFMaker
Отвечает за генерацию pdf документа, на вход принимает имя документа и html код. Имеет один метод:  
`make_pdf()` - генерирует pdf из данных, полученных при инициализации.